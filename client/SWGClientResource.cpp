/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


#include "SWGClientResource.h"

#include "SWGHelpers.h"

#include <QJsonDocument>
#include <QJsonArray>
#include <QObject>
#include <QDebug>

namespace Swagger {


SWGClientResource::SWGClientResource(QString* json) {
    init();
    this->fromJson(*json);
}

SWGClientResource::SWGClientResource() {
    init();
}

SWGClientResource::~SWGClientResource() {
    this->cleanup();
}

void
SWGClientResource::init() {
    access_token_validity_seconds = 0;
    client_key = new QString("");
    grant_types = new QList<QString*>();
    id = 0;
    is_public = false;
    locked = false;
    name = new QString("");
    redirect_uris = new QList<QString*>();
    refresh_token_validity_seconds = 0;
    secret = new QString("");
}

void
SWGClientResource::cleanup() {
    

    if(client_key != nullptr) {
        delete client_key;
    }

    if(grant_types != nullptr) {
        QList<QString*>* arr = grant_types;
        foreach(QString* o, *arr) {
            delete o;
        }
        delete grant_types;
    }




    if(name != nullptr) {
        delete name;
    }

    if(redirect_uris != nullptr) {
        QList<QString*>* arr = redirect_uris;
        foreach(QString* o, *arr) {
            delete o;
        }
        delete redirect_uris;
    }


    if(secret != nullptr) {
        delete secret;
    }
}

SWGClientResource*
SWGClientResource::fromJson(QString &json) {
    QByteArray array (json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
    return this;
}

void
SWGClientResource::fromJsonObject(QJsonObject &pJson) {
    ::Swagger::setValue(&access_token_validity_seconds, pJson["access_token_validity_seconds"], "qint32", "");
    ::Swagger::setValue(&client_key, pJson["client_key"], "QString", "QString");
    
    ::Swagger::setValue(&grant_types, pJson["grant_types"], "QList", "QString");
    
    ::Swagger::setValue(&id, pJson["id"], "qint32", "");
    ::Swagger::setValue(&is_public, pJson["is_public"], "bool", "");
    ::Swagger::setValue(&locked, pJson["locked"], "bool", "");
    ::Swagger::setValue(&name, pJson["name"], "QString", "QString");
    
    ::Swagger::setValue(&redirect_uris, pJson["redirect_uris"], "QList", "QString");
    
    ::Swagger::setValue(&refresh_token_validity_seconds, pJson["refresh_token_validity_seconds"], "qint32", "");
    ::Swagger::setValue(&secret, pJson["secret"], "QString", "QString");
}

QString
SWGClientResource::asJson ()
{
    QJsonObject* obj = this->asJsonObject();
    
    QJsonDocument doc(*obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject*
SWGClientResource::asJsonObject() {
    QJsonObject* obj = new QJsonObject();
    
    obj->insert("access_token_validity_seconds", QJsonValue(access_token_validity_seconds));

    toJsonValue(QString("client_key"), client_key, obj, QString("QString"));

    QJsonArray grant_typesJsonArray;
    toJsonArray((QList<void*>*)grant_types, &grant_typesJsonArray, "grant_types", "QString");
    obj->insert("grant_types", grant_typesJsonArray);

    obj->insert("id", QJsonValue(id));

    obj->insert("is_public", QJsonValue(is_public));

    obj->insert("locked", QJsonValue(locked));

    toJsonValue(QString("name"), name, obj, QString("QString"));

    QJsonArray redirect_urisJsonArray;
    toJsonArray((QList<void*>*)redirect_uris, &redirect_urisJsonArray, "redirect_uris", "QString");
    obj->insert("redirect_uris", redirect_urisJsonArray);

    obj->insert("refresh_token_validity_seconds", QJsonValue(refresh_token_validity_seconds));

    toJsonValue(QString("secret"), secret, obj, QString("QString"));

    return obj;
}

qint32
SWGClientResource::getAccessTokenValiditySeconds() {
    return access_token_validity_seconds;
}
void
SWGClientResource::setAccessTokenValiditySeconds(qint32 access_token_validity_seconds) {
    this->access_token_validity_seconds = access_token_validity_seconds;
}

QString*
SWGClientResource::getClientKey() {
    return client_key;
}
void
SWGClientResource::setClientKey(QString* client_key) {
    this->client_key = client_key;
}

QList<QString*>*
SWGClientResource::getGrantTypes() {
    return grant_types;
}
void
SWGClientResource::setGrantTypes(QList<QString*>* grant_types) {
    this->grant_types = grant_types;
}

qint32
SWGClientResource::getId() {
    return id;
}
void
SWGClientResource::setId(qint32 id) {
    this->id = id;
}

bool
SWGClientResource::getIsPublic() {
    return is_public;
}
void
SWGClientResource::setIsPublic(bool is_public) {
    this->is_public = is_public;
}

bool
SWGClientResource::getLocked() {
    return locked;
}
void
SWGClientResource::setLocked(bool locked) {
    this->locked = locked;
}

QString*
SWGClientResource::getName() {
    return name;
}
void
SWGClientResource::setName(QString* name) {
    this->name = name;
}

QList<QString*>*
SWGClientResource::getRedirectUris() {
    return redirect_uris;
}
void
SWGClientResource::setRedirectUris(QList<QString*>* redirect_uris) {
    this->redirect_uris = redirect_uris;
}

qint32
SWGClientResource::getRefreshTokenValiditySeconds() {
    return refresh_token_validity_seconds;
}
void
SWGClientResource::setRefreshTokenValiditySeconds(qint32 refresh_token_validity_seconds) {
    this->refresh_token_validity_seconds = refresh_token_validity_seconds;
}

QString*
SWGClientResource::getSecret() {
    return secret;
}
void
SWGClientResource::setSecret(QString* secret) {
    this->secret = secret;
}



} /* namespace Swagger */

