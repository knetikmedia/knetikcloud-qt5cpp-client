/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


#include "SWGPageResource«ChallengeResource».h"

#include "SWGHelpers.h"

#include <QJsonDocument>
#include <QJsonArray>
#include <QObject>
#include <QDebug>

namespace Swagger {


SWGPageResource«ChallengeResource»::SWGPageResource«ChallengeResource»(QString* json) {
    init();
    this->fromJson(*json);
}

SWGPageResource«ChallengeResource»::SWGPageResource«ChallengeResource»() {
    init();
}

SWGPageResource«ChallengeResource»::~SWGPageResource«ChallengeResource»() {
    this->cleanup();
}

void
SWGPageResource«ChallengeResource»::init() {
    content = new QList<SWGChallengeResource*>();
    first = false;
    last = false;
    number = 0;
    number_of_elements = 0;
    size = 0;
    sort = new QList<SWGOrder*>();
    total_elements = 0L;
    total_pages = 0;
}

void
SWGPageResource«ChallengeResource»::cleanup() {
    
    if(content != nullptr) {
        QList<SWGChallengeResource*>* arr = content;
        foreach(SWGChallengeResource* o, *arr) {
            delete o;
        }
        delete content;
    }






    if(sort != nullptr) {
        QList<SWGOrder*>* arr = sort;
        foreach(SWGOrder* o, *arr) {
            delete o;
        }
        delete sort;
    }


}

SWGPageResource«ChallengeResource»*
SWGPageResource«ChallengeResource»::fromJson(QString &json) {
    QByteArray array (json.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
    return this;
}

void
SWGPageResource«ChallengeResource»::fromJsonObject(QJsonObject &pJson) {
    
    ::Swagger::setValue(&content, pJson["content"], "QList", "SWGChallengeResource");
    
    ::Swagger::setValue(&first, pJson["first"], "bool", "");
    ::Swagger::setValue(&last, pJson["last"], "bool", "");
    ::Swagger::setValue(&number, pJson["number"], "qint32", "");
    ::Swagger::setValue(&number_of_elements, pJson["number_of_elements"], "qint32", "");
    ::Swagger::setValue(&size, pJson["size"], "qint32", "");
    
    ::Swagger::setValue(&sort, pJson["sort"], "QList", "SWGOrder");
    
    ::Swagger::setValue(&total_elements, pJson["total_elements"], "qint64", "");
    ::Swagger::setValue(&total_pages, pJson["total_pages"], "qint32", "");
}

QString
SWGPageResource«ChallengeResource»::asJson ()
{
    QJsonObject* obj = this->asJsonObject();
    
    QJsonDocument doc(*obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject*
SWGPageResource«ChallengeResource»::asJsonObject() {
    QJsonObject* obj = new QJsonObject();
    
    QJsonArray contentJsonArray;
    toJsonArray((QList<void*>*)content, &contentJsonArray, "content", "SWGChallengeResource");
    obj->insert("content", contentJsonArray);

    obj->insert("first", QJsonValue(first));

    obj->insert("last", QJsonValue(last));

    obj->insert("number", QJsonValue(number));

    obj->insert("number_of_elements", QJsonValue(number_of_elements));

    obj->insert("size", QJsonValue(size));

    QJsonArray sortJsonArray;
    toJsonArray((QList<void*>*)sort, &sortJsonArray, "sort", "SWGOrder");
    obj->insert("sort", sortJsonArray);

    obj->insert("total_elements", QJsonValue(total_elements));

    obj->insert("total_pages", QJsonValue(total_pages));

    return obj;
}

QList<SWGChallengeResource*>*
SWGPageResource«ChallengeResource»::getContent() {
    return content;
}
void
SWGPageResource«ChallengeResource»::setContent(QList<SWGChallengeResource*>* content) {
    this->content = content;
}

bool
SWGPageResource«ChallengeResource»::getFirst() {
    return first;
}
void
SWGPageResource«ChallengeResource»::setFirst(bool first) {
    this->first = first;
}

bool
SWGPageResource«ChallengeResource»::getLast() {
    return last;
}
void
SWGPageResource«ChallengeResource»::setLast(bool last) {
    this->last = last;
}

qint32
SWGPageResource«ChallengeResource»::getNumber() {
    return number;
}
void
SWGPageResource«ChallengeResource»::setNumber(qint32 number) {
    this->number = number;
}

qint32
SWGPageResource«ChallengeResource»::getNumberOfElements() {
    return number_of_elements;
}
void
SWGPageResource«ChallengeResource»::setNumberOfElements(qint32 number_of_elements) {
    this->number_of_elements = number_of_elements;
}

qint32
SWGPageResource«ChallengeResource»::getSize() {
    return size;
}
void
SWGPageResource«ChallengeResource»::setSize(qint32 size) {
    this->size = size;
}

QList<SWGOrder*>*
SWGPageResource«ChallengeResource»::getSort() {
    return sort;
}
void
SWGPageResource«ChallengeResource»::setSort(QList<SWGOrder*>* sort) {
    this->sort = sort;
}

qint64
SWGPageResource«ChallengeResource»::getTotalElements() {
    return total_elements;
}
void
SWGPageResource«ChallengeResource»::setTotalElements(qint64 total_elements) {
    this->total_elements = total_elements;
}

qint32
SWGPageResource«ChallengeResource»::getTotalPages() {
    return total_pages;
}
void
SWGPageResource«ChallengeResource»::setTotalPages(qint32 total_pages) {
    this->total_pages = total_pages;
}



} /* namespace Swagger */

