/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

#ifndef _SWG_SWGUsersInventoryApi_H_
#define _SWG_SWGUsersInventoryApi_H_

#include "SWGHttpRequest.h"

#include <QString>
#include "SWGEntitlementGrantRequest.h"
#include "SWGEntitlementItem.h"
#include "SWGInvoiceResource.h"
#include "SWGItemTemplateResource.h"
#include "SWGPageResource«EntitlementItem».h"
#include "SWGPageResource«ItemTemplateResource».h"
#include "SWGPageResource«UserInventoryResource».h"
#include "SWGPageResource«UserItemLogResource».h"
#include "SWGResult.h"
#include "SWGUserInventoryAddRequest.h"
#include "SWGUserInventoryResource.h"

#include <QObject>

namespace Swagger {

class SWGUsersInventoryApi: public QObject {
    Q_OBJECT

public:
    SWGUsersInventoryApi();
    SWGUsersInventoryApi(QString host, QString basePath);
    ~SWGUsersInventoryApi();

    QString host;
    QString basePath;

    void addItemToUserInventory(qint32 id, SWGUserInventoryAddRequest user_inventory_add_request);
    void checkUserEntitlementItem(QString* user_id, qint32 item_id, QString* sku);
    void createEntitlementItem(bool cascade, SWGEntitlementItem entitlement_item);
    void createEntitlementTemplate(SWGItemTemplateResource template);
    void deleteEntitlementItem(qint32 entitlement_id);
    void deleteEntitlementTemplate(QString* id, QString* cascade);
    void getEntitlementItem(qint32 entitlement_id);
    void getEntitlementItems(qint32 size, qint32 page, QString* order);
    void getEntitlementTemplate(QString* id);
    void getEntitlementTemplates(qint32 size, qint32 page, QString* order);
    void getUserInventories(qint32 id, bool inactive, qint32 size, qint32 page, QString* filter_item_name, qint32 filter_item_id, QString* filter_username, QString* filter_group, QString* filter_date);
    void getUserInventory(qint32 user_id, qint32 id);
    void getUserInventoryLog(QString* user_id, qint32 id, qint32 size, qint32 page);
    void getUsersInventory(bool inactive, qint32 size, qint32 page, QString* filter_item_name, qint32 filter_item_id, QString* filter_username, QString* filter_group, QString* filter_date);
    void grantUserEntitlement(qint32 user_id, SWGEntitlementGrantRequest grant_request);
    void updateEntitlementItem(qint32 entitlement_id, bool cascade, SWGEntitlementItem entitlement_item);
    void updateEntitlementTemplate(QString* id, SWGItemTemplateResource template);
    void updateUserInventoryBehaviorData(qint32 user_id, qint32 id, SWGObject* data);
    void updateUserInventoryExpires(qint32 user_id, qint32 id, qint64 timestamp);
    void updateUserInventoryStatus(qint32 user_id, qint32 id, QString* inventory_status);
    void useUserEntitlementItem(QString* user_id, qint32 item_id, QString* sku, QString* info);
    
private:
    void addItemToUserInventoryCallback (HttpRequestWorker * worker);
    void checkUserEntitlementItemCallback (HttpRequestWorker * worker);
    void createEntitlementItemCallback (HttpRequestWorker * worker);
    void createEntitlementTemplateCallback (HttpRequestWorker * worker);
    void deleteEntitlementItemCallback (HttpRequestWorker * worker);
    void deleteEntitlementTemplateCallback (HttpRequestWorker * worker);
    void getEntitlementItemCallback (HttpRequestWorker * worker);
    void getEntitlementItemsCallback (HttpRequestWorker * worker);
    void getEntitlementTemplateCallback (HttpRequestWorker * worker);
    void getEntitlementTemplatesCallback (HttpRequestWorker * worker);
    void getUserInventoriesCallback (HttpRequestWorker * worker);
    void getUserInventoryCallback (HttpRequestWorker * worker);
    void getUserInventoryLogCallback (HttpRequestWorker * worker);
    void getUsersInventoryCallback (HttpRequestWorker * worker);
    void grantUserEntitlementCallback (HttpRequestWorker * worker);
    void updateEntitlementItemCallback (HttpRequestWorker * worker);
    void updateEntitlementTemplateCallback (HttpRequestWorker * worker);
    void updateUserInventoryBehaviorDataCallback (HttpRequestWorker * worker);
    void updateUserInventoryExpiresCallback (HttpRequestWorker * worker);
    void updateUserInventoryStatusCallback (HttpRequestWorker * worker);
    void useUserEntitlementItemCallback (HttpRequestWorker * worker);
    
signals:
    void addItemToUserInventorySignal(SWGInvoiceResource* summary);
    void checkUserEntitlementItemSignal();
    void createEntitlementItemSignal(SWGEntitlementItem* summary);
    void createEntitlementTemplateSignal(SWGItemTemplateResource* summary);
    void deleteEntitlementItemSignal();
    void deleteEntitlementTemplateSignal();
    void getEntitlementItemSignal(SWGEntitlementItem* summary);
    void getEntitlementItemsSignal(SWGPageResource«EntitlementItem»* summary);
    void getEntitlementTemplateSignal(SWGItemTemplateResource* summary);
    void getEntitlementTemplatesSignal(SWGPageResource«ItemTemplateResource»* summary);
    void getUserInventoriesSignal(SWGPageResource«UserInventoryResource»* summary);
    void getUserInventorySignal(SWGUserInventoryResource* summary);
    void getUserInventoryLogSignal(SWGPageResource«UserItemLogResource»* summary);
    void getUsersInventorySignal(SWGPageResource«UserInventoryResource»* summary);
    void grantUserEntitlementSignal();
    void updateEntitlementItemSignal();
    void updateEntitlementTemplateSignal(SWGItemTemplateResource* summary);
    void updateUserInventoryBehaviorDataSignal();
    void updateUserInventoryExpiresSignal();
    void updateUserInventoryStatusSignal();
    void useUserEntitlementItemSignal();
    
};
}
#endif
